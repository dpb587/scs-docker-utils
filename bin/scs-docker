#!/usr/bin/env node

var fs = require('fs');
var os = require('os');
var path = require('path');
var util = require('util');

var Config = require('../src/util/config');
var Profile = require('../src/util/profile');

// --

var cli = new (require('argparse').ArgumentParser)({ description : 'Create a dynamic forwarding agent for etcd-based service discovery.' });

cli.addArgument([ '--log-level' ], { help : 'logging level', defaultValue : 'info' });

cli.addArgument([ '--compiled-file' ], { help : 'file to store compiled configuration', defaultValue : 'compiled.json', metavar : 'PATH' });

cli.addArgument([ 'command' ], { help : 'command to run', choices : [ 'cache-put', 'cache-get', 'build', 'run', 'run-load', 'run-unload' ] });
cli.addArgument([ 'runconf' ], { help : 'file(s) containing the runtime configuration', defaultValue : [ 'runtime.json' ], nargs : '*' });

var cliargs = cli.parseArgs();

var logger = require('npmlog');
logger.level = cliargs.log_level;

// --

var profile;

// --

process.on('exit', function () {
    if (profile && profile.ccompiled) {
        fs.writeFileSync(cliargs.compiled_file, JSON.stringify(profile.ccompiled.config, null, 2));
    }
});

process.on('uncaughtException', function (error) {
    logger.error('process/error', error.toString());
    logger.info('process/error', error.stack);

    process.exit(1);
});

// --

logger.silly('process/args', JSON.stringify(cliargs));

function abspath(p) {
    return path.resolve(process.cwd(), p);
}

cliargs.runconf = cliargs.runconf.map(abspath);
cliargs.compiled_file = abspath(cliargs.compiled_file);

logger.verbose('process/args', JSON.stringify(cliargs));

// --

var cruntime = new Config();
cruntime.importFiles(cliargs.runconf);
cruntime.log(logger, 'silly', 'scs/runtime');

// --

var ccompiled = new Config();

if (fs.existsSync(cliargs.compiled_file)) {
    ccompiled.importFile(cliargs.compiled_file);
}

ccompiled.log(logger, 'silly', 'scs/compiled');

// --

var profile = new Profile(cruntime, ccompiled, logger);

if (profile.needsRecompilation()) {
    profile.recompile(function (error, result) {
        if (error) {
            throw error;

            return;
        }

        console.log(JSON.stringify(profile.ccompiled.config, null, 2));
    });
}

return;


// --


return;
// --

var profile = new Profile(
    coreconf,
    runconf,
    compconf,
    logger
);

var workflow = new Workflow(null, logger, 'scs-docker');

if ('run' == cliargs.command) {
    var container;

    if (!compconf.has('imageconf')) {
        workflow.pushStep(
            'gather-runtime',
            function (workflow, callback) {
                profile.createGatheringWorkflow().run(callback);
            }
        );
    }

    workflow.pushStep(
        'check-image',
        function (workflow, callback) {
            profile.getImageEngine().hasImage(
                function (error, result) {
                    if (error) {
                        callback(error);

                        return;
                    }

                    if (!result) {
                        workflow.unshiftStep(
                            'build-image',
                            function (workflow, callback) {
                                profile.createImageBuildingWorkflow().run(callback);
                            }
                        );
                    }

                    callback();
                }
            );
        }
    );

    workflow.pushStep(
        'run-image',
        function (workflow, callback) {
            profile.startContainer(
                function (error, result) {
                    if (error) {
                        callback(error);

                        return;
                    }

                    container = result;
                }
            );
        }
    )

    function handleSignal(signal) {
        logger.info('process/kill', signal);

        if (container) {
            container.stop(
                function (error, result) {
                    if (error) {
                        throw error;

                        return;
                    }

                    logger.verbose('run', 'finished');
                }
            );
        }
    }

    process.on('SIGINT', function () { handleSignal('SIGINT'); });
    process.on('SIGTERM', function () { handleSignal('SIGTERM'); });
}

workflow.run(
    function (error, result) {
        if (error) {
            logger.error(error.toString());
            logger.info(error.stack);

            process.exit(1);

            return;
        }

        logger.silly('root workflow complete');
    }
);
