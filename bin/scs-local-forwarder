#!/usr/bin/env node

var http = require('http');
var net = require('net');
var child_process = require('child_process');

var cli = new (require('argparse').ArgumentParser)(
  {
    description : 'Create a dynamic forwarding agent for etcd-based service discovery.'
  }
);

cli.addArgument([ '--log-level' ], { help : 'logging level', defaultValue : 'info' });
cli.addArgument([ '--etcd' ], { help : 'etcd cluster', defaultValue : '127.0.0.1:4001', metavar : 'HOST[:PORT]' });
cli.addArgument([ '--provide' ], { help : 'tunnel a provided protocol', action : 'append', required : true, metavar : 'ROLE:PROVIDER:LOCALPORT' });
cli.addArgument([ '--host' ], { help : 'local hostname' });
cli.addArgument([ '--ip' ], { help : 'local ip', required : true });
cli.addArgument([ '--zone' ], { help : 'zone', defaultValue : 'default' });
cli.addArgument([ 'environment' ], { help : 'environment' });
cli.addArgument([ 'service' ], { help : 'service' });

var cliargs = cli.parseArgs();

cliargs.etcd = cliargs.etcd.split(':');
cliargs.etcd[1] = parseInt(cliargs.etcd[1], 10) || 4001;

var logger = require('npmlog');
logger.level = cliargs.log_level;

logger.silly('args', JSON.stringify(cliargs));

var etcd = new (require('node-etcd'))(cliargs.etcd[0], cliargs.etcd[1]);

var watchers = {};
var forwarders = {};
var endpoints = {};
var reloadtimers = {};

function reloadEndpoint(provide) {
  var providez = provide.split(':');

  etcd.get(
    cliargs.zone + '/service-locator/' + cliargs.environment + '/' + cliargs.service + '/' + providez[0] + '/' + providez[1],
    {
      recursive : true
    },
    function (err, data) {
      logger.silly(providez[0] + '/' + providez[1] + '/endpoint', JSON.stringify(data));

      updateForwarder(provide, data);

      if (!(provide in watchers)) {
        createWatcher(provide);
      }
    }
  );
}

function createWatcher(provide) {
  var providez = provide.split(':');

  watchers[provide] = etcd.watcher(
    cliargs.zone + '/service-locator/' + cliargs.environment + '/' + cliargs.service + '/' + providez[0] + '/' + providez[1],
    null,
    {
      recursive : true
    }
  );

  watchers[provide].on(
    'change',
    function (data) {
      logger.silly(providez[0] + '/' + providez[1] + '/watcher', JSON.stringify(data));

      reloadEndpoint(provide);
    }
  );
}

function updateForwarder(provide, data) {
  var providez = provide.split(':');

  if (!('node' in data) || !('nodes' in data['node'])) {
    logger.error(providez[0] + '/' + providez[1] + '/forwarder', 'unable to discover endpoint; retrying in 10s...');

    endpoints[provide] = null;

    reloadtimers[provide] = setTimeout(
      function () {
        reloadEndpoint(provide);
      },
      10000
    );

    return;
  }

  clearTimeout(reloadtimers[provide]);

  var endpoint = data['node']['nodes'][0]['value'];

  if (endpoint == endpoints[provide]) {
    return;
  }

  endpoints[provide] = endpoint.split(':');

  logger.info(providez[0] + '/' + providez[1] + '/forwarder', 'endpoint is ' + endpoints[provide].slice(0, 2).join(':'));

  if (provide in forwarders) {
    return;
  }

  forwarders[provide] = net.createServer(
    function (from) {
      logger.verbose(providez[0] + '/' + providez[1] + '/forwarder', 'connection ' + from.remoteAddress + ':' + from.remotePort + ' -> ' + endpoints[provide][0] + ':' + endpoints[provide][1]);

      var to = net.createConnection(
        {
          host : endpoints[provide][0],
          port : endpoints[provide][1]
        }
      )
        .on(
          'error',
          function (err) {
            logger.error(providez[0] + '/' + providez[1] + '/forwarder', err.message);
          }
        )
        ;

      from.pipe(to);
      to.pipe(from);
    }
  )
    .listen(parseInt(providez[2], 10), cliargs.ip)
    .on(
      'listening',
      function () {
        logger.info(providez[0] + '/' + providez[1] + '/forwarder', 'started');
      }
    )
    .on(
      'close',
      function () {
        logger.info(providez[0] + '/' + providez[1] + '/forwarder', 'stopped');
      }
    )
    ;
}

function stop() {
  for (var provide in forwarders) {
    var providez = provide.split(':');

    logger.verbose(providez[0] + '/' + providez[1] + '/forwarder', 'stopping');

    forwarders[provide].close();

    delete forwarders[provide];
  }

  for (var provide in watchers) {
    var providez = provide.split(':');

    logger.verbose(providez[0] + '/' + providez[1] + '/watcher', 'stopping');

    watchers[provide].request.abort();
  }

  for (var provide in reloadtimers) {
    clearTimeout(reloadtimers[provide]);
  }
}

if (cliargs.host) {
  child_process.exec(
    '/sbin/ifconfig lo0 alias ' + cliargs.ip + ' && (/usr/bin/grep "' + cliargs.ip + ' ' + cliargs.host + '" /etc/hosts > /dev/null || /bin/echo "' + cliargs.ip + ' ' + cliargs.host + '" >> /etc/hosts)',
    function (err, stdout, stderr) {
      logger.silly('localhost:stdout', stdout);
      logger.silly('localhost:stderr', stderr);
      logger.silly('localhost:code', err ? err.code : 0);

      if (err) {
        throw new Error('Unable to route');
      }

      logger.verbose('localhost', 'routed ' + cliargs.ip + ' to ' + cliargs.host);

      cliargs.provide.forEach(reloadEndpoint);
    }
  );
} else {
  cliargs.provide.forEach(reloadEndpoint);
}

process
  .on(
    'SIGINT',
    function () {
      logger.info('process', 'received SIGINT');

      stop();
    }
  )
  .on(
    'SIGTERM',
    function () {
      logger.info('process', 'received SIGTERM');

      stop();
    }
  )
  ;
