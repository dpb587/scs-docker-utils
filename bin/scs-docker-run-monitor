#!/usr/bin/env node

var http = require('http');

var cli = new (require('argparse').ArgumentParser)(
  {
    description : 'Monitor etcd and signal a process when changes occur.'
  }
);

cli.addArgument([ '--etcd' ], { help : 'etcd cluster host and port', defaultValue : '127.0.0.1:4001', metavar : 'HOST:PORT' });
cli.addArgument([ '--notify-pid' ], { help : 'notify process id on change', required : true, type : 'int' });
cli.addArgument([ '--notify-signal' ], { help : 'notify process with signal', defaultValue : 'SIGUSR1' });
cli.addArgument([ '--log-level' ], { help : 'logging level', defaultValue : 'info' });
cli.addArgument([ 'etcdpath' ], { help : 'path(s) to monitor etcd for changes', nargs : '*' });

var cliargs = cli.parseArgs();

cliargs.etcd = cliargs.etcd.split(':', 2);

var logger = require('npmlog');
logger.level = cliargs.logLevel;

logger.silly('args', JSON.stringify(cliargs));

var notifyTimeout;

function queueNotify() {
  clearTimeout(notifyTimeout);

  notifyTimeout = setTimeout(
    function () {
      process.kill(cliargs.notify_pid, cliargs.notify_signal);

      logger.info('notify', 'sent ' + cliargs.notify_signal + ' to ' + cliargs.notify_pid);
    },
    500
  );
}

var shuttingdown = false;
var requests = [];

function watchPath(path) {
  if (shuttingdown) {
    return;
  }

  var timedout = false;

  var req = http.request(
    {
      host : cliargs.etcd[0],
      port : cliargs.etcd[1],
      path : '/v2/keys/' + path + '?recursive=true&wait=true'
    },
    function (res) {
      res.setEncoding('utf8');
      res.on(
        'data',
        function (chunk) {
          logger.warn(path, chunk);

          queueNotify();
        }
      );
      res.on(
        'end',
        function () {
          delete requests[path];

          watchPath(path);
        }
      );
    }
  );

  req.setTimeout(
    120000,
    function () {
      timedout = true;

      this.end();
      req.abort();

      delete requests[path];

      watchPath(path);
    }
  );

  req.on(
    'error',
    function (err) {
      if (shuttingdown || timedout) {
        return;
      }

      logger.warn(path, 'Error: ' + err.message);

      delete requests[path];

      setTimeout(
        function () {
          watchPath(path);
        },
        10000
      );
    }
  );

  req.end();

  requests[path] = req;
}

cliargs.etcdpath.forEach(
  function (path) {
    watchPath(path);
  }
);

function shutdown() {
  shuttingdown = true;

  for (var path in requests) {
    logger.verbose(path, 'aborting request');

    requests[path].abort();
  }
}

process.on(
  'SIGINT',
  function () {
    logger.info('SIGINT', 'shutting down requests');

    shutdown();
  }
);

process.on(
  'SIGTERM',
  function () {
    logger.info('SIGTERM', 'shutting down requests');

    shutdown();
  }
);