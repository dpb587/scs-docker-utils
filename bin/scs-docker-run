#!/usr/bin/env node

var child_process = require('child_process');
var crypto = require('crypto');
var fs = require('fs');
var yaml = require('js-yaml');

var cli = new (require('argparse').ArgumentParser)(
  {
    description : 'Run an SCS container.'
  }
);

cli.addArgument([ 'manifest' ], { help : 'Local path to configuration file' })
cli.addArgument([ '--log-level' ], { help : 'logging level', defaultValue : 'info' });

var cliargs = cli.parseArgs();

var logger = require('npmlog');
logger.level = cliargs.log_level;

logger.silly('args', JSON.stringify(cliargs));

config_stateful = JSON.parse(fs.readFileSync(cliargs.manifest, { encoding : 'utf8' }));
config_definition = yaml.safeLoad(fs.readFileSync('/var/lib/docker/aufs/mnt/' + config_stateful['docker']['image'] + '/scs/scs/manifest.yaml', { encoding : 'utf8' }));
config_runtime = yaml.safeLoad(fs.readFileSync('/var/lib/scs-docker/' + config_stateful['ident']['local'] + '/manifest.yaml', { encoding : 'utf8' }));

var etcd = new (require('node-etcd'))(config_stateful['etcd'][0], config_stateful['etcd'][1] || 4001);

var env = {
  SCS_ENVIRONMENT : config_stateful['name']['environment'],
  SCS_SERVICE : config_stateful['name']['service'],
  SCS_ROLE : config_stateful['name']['role'],
  SCS_RUN_ZONE : config_stateful['zone']
}

child_process.exec(
  'hostname',
  function (error, stdout, stderr) {
    if (error) throw error;

    env.SCS_RUN_HOST = stdout.trim();

    mainReady();
  }
);

child_process.exec(
  'hostname -I | awk \'{ print $1 }\'',
  function (error, stdout, stderr) {
    if (error) throw error;

    env.SCS_RUN_ADDR = stdout.trim();

    mainReady();
  }
);

var container;
var containerid;
var endpoints = {};
var watchers = {};
var discoveries = {};
var dockerargs = [
  'run',
  '-cidfile', '/var/lib/scs-docker/' + config_stateful['ident']['local'] + '/container'
];

function parseEndpoint(str) {
  Object.keys(env).forEach(
    function (key) {
      str = str.replace('%(' + key + ')s', env[key]);
    }
  );

  return str;
}

function updateRequiredEndpoint(key, data) {
  if (!('nodes' in data['node'])) {
    data['node']['nodes'] = [ { 'value' : '127.0.0.1:1' } ];
    //throw new Error('No endpoint found for ' + key);
  }

  var endpoint = data['node']['nodes'][0]['value'];

  if (endpoint == endpoints[key]) {
    return;
  }

  endpoints[key] = endpoint;

  logger.info('scs/require/' + key, 'endpoint is ' + endpoints[key].split(':').slice(0, 2).join(':'));

  if (key in discoveries) {
    delete discoveries[key];

    dockerargs.push('-e', 'SCS_REQUIRES_' + key.toUpperCase() + '=' + endpoints[key]);

    runReady();
  } else {
    if ('liveupdate' in config_definition['requires'][key]) {
      var liveenv = {};
      liveenv['SCS_REQUIRES_' + key.toUpperCase()] = endpoints[key];

      child_process.spawn(
        'lxc-attach',
        [
          '-n',
          containerid,
          '--keep-env',
          config_definition['requires'][key]['liveupdate']
        ],
        {
          env : liveenv,
          timeout : 30,
          stdio : 'inherit'
        }
      ).on(
        'close',
        function (code) {
          if (code) {
            logger.error('scs/require/' + key, 'live-update failed (exited ' + code + ')');

            process.kill(process.pid, 'SIGTERM');

            return;
          }

          logger.info('scs/require/' + key, 'live-update successful');
        }
      );

      logger.info('scs/require/' + key, 'live-update initiated');
    } else {
      logger.warn('scs/require/' + key, 'live-update not supported');

      process.kill(process.pid, 'SIGTERM');
    }
  }
}

function reloadRequiredEndpoint(key) {
  return etcd.get(
    parseEndpoint(config_runtime['requires'][key]['options']['path']),
    {
      recursive : true
    },
    function (err, data) {
      logger.silly('scs/require/' + key, JSON.stringify(data));

      updateRequiredEndpoint(key, data);

      if (!(key in watchers)) {
        createWatcher(key)
      }
    }
  );
}

function createWatcher(key) {
  watchers[key] = etcd.watcher(
    parseEndpoint(config_runtime['requires'][key]['options']['path']),
    null,
    {
      recursive : true
    }
  );

  watchers[key].on(
    'change',
    function (err, data) {
      logger.silly('scs/require-watcher/' + key, JSON.stringify(data));

      reloadRequiredEndpoint(key);
    }
  );
}

function mainReady() {
  if (6 != Object.keys(env).length) {
    return;
  }

  var hash = crypto.createHash('sha1');
  hash.update(env.SCS_RUN_HOST + '\n');
  hash.update(config_stateful['ident']['common'] + '\n');
  hash.update(config_stateful['ident']['local'] + '\n');

  env['SCS_RUN_NAME'] = hash.digest('hex').substr(0, 12);

  dockerargs.push('-e', 'SCS_RUN_ZONE=' + env.SCS_RUN_ZONE);
  dockerargs.push('-e', 'SCS_RUN_HOST=' + env.SCS_RUN_HOST);
  dockerargs.push('-e', 'SCS_RUN_ADDR=' + env.SCS_RUN_ADDR);

  if ('provides' in config_definition) {
    for (var key in config_definition['provides']) {
      dockerargs.push('-p', config_definition['provides'][key]['port']);
    }
  }

  if ('volumes' in config_definition) {
    for (var key in config_definition['volumes']) {
      dockerargs.push('-v', config_stateful['volumes'][key]['path'] + ':/scs-mnt/' + key);
    }
  }

  if ('requires' in config_definition) {
    for (var key in config_definition['requires']) {
      if ('etcd_watch' == config_runtime['requires'][key]['method']) {
        discoveries[key] = reloadRequiredEndpoint(key);
      } else {
        throw new Error('unsupported discovery for "' + key + '"');
      }
    }
  }

  runReady();
}

function runReady() {
  if (0 != Object.keys(discoveries).length) return;

  dockerargs.push(config_stateful['docker']['image']);
  dockerargs.push('/scs/scs/bin/run');

  logger.verbose('docker/run', dockerargs.join(' '));

  container = child_process.spawn(
    'docker',
    dockerargs,
    {
      stdio : 'inherit'
    }
  );

  container.on(
    'close',
    function (code) {
      unregisterProvisions();
      stopWatchers();

      fs.unlink(
        '/var/lib/scs-docker/' + config_stateful['ident']['local'] + '/container',
        function () {
          logger.verbose('scs/docker', 'removed container file');
        }
      );
    }
  );

  setTimeout(
    function () {
      containerid = fs.readFileSync('/var/lib/scs-docker/' + config_stateful['ident']['local'] + '/container', { encoding : 'utf8' })

      registerProvisions();
    },
    5000
  );
}

var registered = {};

function registerProvisions() {
  if (!('provides' in config_definition)) return;

  for (var key in config_definition['provides']) {
    child_process.exec(
      'docker port ' + containerid + ' ' + config_definition['provides'][key]['port'],
      function (error, stdout, stderr) {
        var endpoint = stdout.trim().replace('0.0.0.0:', env.SCS_RUN_ADDR + ':');
        registered[key] = true;

        etcd.set(
          [
            env.SCS_RUN_ZONE,
            'service-locator',
            env.SCS_ENVIRONMENT,
            env.SCS_SERVICE,
            env.SCS_ROLE,
            key,
            env.SCS_RUN_ADDR + '-' + env.SCS_RUN_NAME
          ].join('/'),
          endpoint,
          {
            ttl : 480
          },
          function () {
            logger.info('scs/provide/' + key, 'registered endpoint (' + endpoint + ')');
          }
        );
      }
    );
  }

  setTimeout(registerProvisions, 300000);
}

function unregisterProvisions() {
  if (!('provides' in config_definition)) return;

  for (var key in config_definition['provides']) {
    if (!(key in registered)) continue;

    delete registered[key];

    etcd.del(
      [
        env.SCS_RUN_ZONE,
        'service-locator',
        env.SCS_ENVIRONMENT,
        env.SCS_SERVICE,
        env.SCS_ROLE,
        key,
        env.SCS_RUN_ADDR + '-' + env.SCS_RUN_NAME
      ].join('/'),
      function () {
        logger.info('scs/provide/' + key, 'unregistered endpoint');
      }
    );
  }
}

function handleSignal(signal) {
  logger.info('scs/process', 'received ' + signal);

  unregisterProvisions();
  stopWatchers();
  container.kill(signal);
}

function stopWatchers() {
  for (var name in watchers) {
    watchers[name].stop();
    delete watchers[name];
  }
}

process.on('SIGINT', function () { handleSignal('SIGINT'); });
process.on('SIGTERM', function () { handleSignal('SIGTERM'); });
process.on('SIGHUP', function () { handleSignal('SIGHUP'); });
