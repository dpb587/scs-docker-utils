#!/usr/bin/env python

import argparse
import boto.ec2
import datetime
import hashlib
import os
import re
import simplejson
import string
import subprocess
import sys
import time
import urllib2
import yaml

cli = argparse.ArgumentParser(description='Deploy an SCS configuration and provision the necessary requirements. This command is idempotent.')
cli.add_argument('environment_name', help='Environment name (e.g. prod)')
cli.add_argument('service_name', help='Service name (e.g. public-blog)')
cli.add_argument('role_name', help='Role name (e.g. web-wordpress)')
cli.add_argument('manifest', help='Local path to configuration file')
cli.add_argument('--zone', help='A delegation zone', default='default')
cli.add_argument('--etcd', help='The etcd cluster for service registration', default='127.0.0.1:4001', metavar='HOST[:PORT]')
cli.add_argument('--source-reference', help='Commit reference to use when a manifest does not provide a canonical one', metavar='REF')
cli.add_argument('--suffix-name', help='Suffix the local name (for multiple deploys)', metavar='SUFFIX')
cli.add_argument('--no-build', help='Do not build an image if one does not already exist locally', action='store_true')
cli.add_argument('--no-supervisor-control', help='Do not send supervisor control calls after changes', action='store_true')
cli.add_argument('--build-args', help='Arguments to pass to scs-docker-build')
cli.add_argument('--supervisor-control-conf', help='Path to configuration for supervisorctl control calls', default='/etc/supervisor/supervisord.conf')
cli.add_argument('--supervisor-program-conf', help='Path to write supervisor program configuration', default='/etc/supervisor/%s.ini')
cli.add_argument('--verbose', '-v', action='count', help='Use multiple times to increase verbosity: none = quiet, 1 = completions, 2 = summaries, 3 = details')

cliargs = cli.parse_args()

#
# setup our basics
#

ec2instance = simplejson.loads(urllib2.urlopen('http://169.254.169.254/latest/dynamic/instance-identity/document').read())
ec2api = boto.ec2.connect_to_region(ec2instance['region'])

DEVNULL = open(os.devnull, 'w')

if cliargs.verbose > 2:
  TASK_STDOUT = sys.stdout
  TASK_STDERR = sys.stderr
else:
  TASK_STDOUT = DEVNULL
  TASK_STDERR = DEVNULL

absmanifest = os.path.abspath(cliargs.manifest)

#
# load configuration
#

config_runtime = yaml.safe_load(open(cliargs.manifest, 'r').read())


#
# resolve source reference
#

if 'git' == config_runtime['source']['type']:
  if 'reference' in config_runtime['source']:
    niceref = config_runtime['source']['reference']
  elif cliargs.source_reference:
    niceref = cliargs.source_reference
  else:
    niceref = 'master'

  if not re.search(r"[a-f0-9]{40}", niceref):
    # seems like a reference; try to find from the remote
    p = subprocess.Popen(
      'git ls-remote "%s" | grep -E \'refs/(heads|tags)/%s\' | awk \'{ print $1 }\'' % ( config_runtime['source']['url'], niceref ),
      shell=True,
      stdout=subprocess.PIPE
    )

    if 0 < p.returncode:
      raise RuntimeError('Unable to resolve source reference "%s".' % niceref)

    realref = p.stdout.read().strip()
  else:
    realref = niceref

  if 0 == len(realref):
    raise RuntimeError('Unable to resolve source reference "%s".' % niceref)
else:
  raise RuntimeError('Unexpected source type.')


#
# identifiers
#

identCommon = '%s--%s--%s' % (
  cliargs.environment_name,
  cliargs.service_name,
  cliargs.role_name,
)
identCompilation = hashlib.md5(
  '%s\n%s\n%s\n%s' % (
    identCommon,
    realref,
    yaml.dump(config_runtime['source']),
    yaml.dump(config_runtime['config']),
  )
).hexdigest()
identFriendly = '%s--%s' % ( identCommon, identCompilation[:12] )

if cliargs.suffix_name:
  identLocal = '%s--%s' % ( identCommon, cliargs.suffix_name )
else:
  identLocal = identCommon


#
# load image definition
#

p = subprocess.Popen(
  'docker inspect -format "{{.id}}" %s' % identFriendly,
  shell=True,
  stdout=subprocess.PIPE
)

p.wait()

if 0 < p.returncode:
  # seems like the image isn't here
  if cliargs.no_build:
    raise RuntimeError('Unable to inspect the expected image and was told not to build one.')

  # try to build one
  if 1 < cliargs.verbose:
    sys.stdout.write('building image...\n')

  subprocess.check_call(
    'scs-docker-build --source-reference %s -vvv %s %s %s %s %s' % (
      realref,
      cliargs.build_args,
      cliargs.environment_name,
      cliargs.service_name,
      cliargs.role_name,
      cliargs.manifest,
    ),
    shell = True,
    stdout = TASK_STDOUT,
    stderr = TASK_STDERR,
  )

  if 0 < cliargs.verbose:
    sys.stdout.write('built image\n')

  # try lookup again
  p = subprocess.Popen(
    'docker inspect -format "{{.id}}" %s' % identFriendly,
    shell=True,
    stdout=subprocess.PIPE
  )

  if 0 < p.returncode:
    raise RuntimeError('Unable to inspect the expected image and the build apparently failed.')

imageid = p.stdout.read().strip()

config_definition = yaml.safe_load(open('/var/lib/docker/aufs/mnt/%s/scs/scs/manifest.yaml' % imageid, 'r').read())


#
# load previous state
#

if not os.path.exists('/var/lib/scs-docker'):
  os.mkdir('/var/lib/scs-docker', 0700)
if not os.path.exists('/var/lib/scs-docker/%s' % identLocal):
  os.mkdir('/var/lib/scs-docker/%s' % identLocal, 0700)

if os.path.exists('/var/lib/scs-docker/%s/run.json' % identLocal):
  config_stateful = simplejson.load(open('/var/lib/scs-docker/%s/run.json' % identLocal, 'r'))
else:
  config_stateful = {}

if 'docker' not in config_stateful:
  config_stateful['docker'] = {}
if 'volumes' not in config_stateful:
  config_stateful['volumes'] = {}
if 'requires' not in config_stateful:
  config_stateful['requires'] = {}

config_stateful['source'] = {
  'reference' : realref,
}
config_stateful['docker'] = {
  'image' : imageid,
}
config_stateful['etcd'] = cliargs.etcd.split(':')
config_stateful['zone'] = cliargs.zone
config_stateful['name'] = {
  'environment' : cliargs.environment_name,
  'service' : cliargs.service_name,
  'role' : cliargs.role_name
}
config_stateful['ident'] = {
  'common' : identCommon,
  'compilation' : identCompilation,
  'friendly' : identFriendly,
  'local' : identLocal,
}


def excepthook(type, value, traceback):
  writeconfig_stateful()
  sys.__excepthook__(type, value, traceback)

def writeconfig_stateful():
  simplejson.dump(config_stateful, open('/var/lib/scs-docker/%s/run.json' % identLocal, 'w'))

sys.excepthook = excepthook

#
# check available volumes, if necessary
#

devicemap = {
  '/dev/sdf' : '/dev/xvdf',
  '/dev/sdg' : '/dev/xvdg',
  '/dev/sdh' : '/dev/xvdh',
  '/dev/sdi' : '/dev/xvdi',
  '/dev/sdj' : '/dev/xvdj',
  '/dev/sdk' : '/dev/xvdk',
  '/dev/sdl' : '/dev/xvdl',
  '/dev/sdm' : '/dev/xvdm',
  '/dev/sdn' : '/dev/xvdn',
  '/dev/sdo' : '/dev/xvdo',
  '/dev/sdp' : '/dev/xvdp',
}

if 'volumes' in config_runtime:
  volumes = ec2api.get_all_volumes(filters = { 'attachment.instance-id' : ec2instance['instanceId'] })

  for volume in volumes:
    if volume.attach_data.device in devicemap:
      del devicemap[volume.attach_data.device]


#
# handle volume mounts
#

for volkey in config_runtime['volumes']:
  volval = config_runtime['volumes'][volkey] 

  volmap = False

  # see if we're already supposed to use a volume
  if volkey in config_stateful['volumes']:
    volmap = config_stateful['volumes'][volkey]

  if 'aws_ec2_ebs' == volval['method']:
    if False == volmap:
      voldevice = False

      for key in devicemap:
        voldevice = devicemap[key]
        del devicemap[key]

        break

      if False == voldevice:
        raise RuntimeError('No devices are available.')

      rolename = '%s/%s' % ( cliargs.role_name, volkey )

      if 'name' in volval['options']:
        if 'role' in volval['options']['name']:
          rolename = volval['options']['name']['role']

      if 'mkfs' in volval['options']:
        mkfs = volval['options']['mkfs']
      else:
        mkfs = ''

      subprocess.check_call(
        'scs-volume-aws-ec2-ebs-mount -vvv --fstab --mkfs-type "%s" --mkfs-args "%s" --volume-size "%s" "%s" "%s" "%s" "%s" "%s"' % \
          (
            volval['options']['format'],
            mkfs,
            volval['options']['size'],
            cliargs.environment_name,
            cliargs.service_name,
            rolename,
            voldevice,
            '/mnt/%s--%s' % ( identLocal, volkey )
          )
          ,
        shell=True
      )

      config_stateful['volumes'][volkey] = {}
      config_stateful['volumes'][volkey]['device'] = voldevice
      config_stateful['volumes'][volkey]['path'] = '/mnt/%s--%s' % ( identLocal, volkey )
  elif 'local' == volval['method']:
    if False == volmap:
      if 'volume' in volval['options']:
        path = '%s/%s' % ( config_stateful['volumes'][volval['options']['volume']]['path'], volval['options']['path'] )
      else:
        path = volval['options']['path']

      if not os.path.exists(path):
        os.mkdir(path, 0700)

      config_stateful['volumes'][volkey] = {}
      config_stateful['volumes'][volkey]['path'] = path
  else:
    raise RuntimeError('Unexpected volume method')


#
# write supervisor config
#

conf = []
conf.append('[program:%s]' % identLocal)
conf.append('command = scs-docker-run /var/lib/scs-docker/%s/run.json' % identLocal)
conf.append('autorestart = true')
conf.append('stdout_logfile = /var/log/supervisor/%(program_name)s-stdout.log')
conf.append('stderr_logfile = /var/log/supervisor/%(program_name)s-stderr.log')

open(cliargs.supervisor_program_conf % identLocal, 'w').write('\n'.join(conf))


#
# supervisor control calls
#

if not cliargs.no_supervisor_control:
  if cliargs.verbose > 1:
    sys.stdout.write('updating supervisord...\n')

  subprocess.check_call(
    [ 'supervisorctl', '-c', cliargs.supervisor_control_conf, 'update' ],
    stdout=TASK_STDOUT,
    stderr=TASK_STDERR
  )

  if cliargs.verbose > 0:
    sys.stdout.write('updated supervisord\n')

writeconfig_stateful()
